# rotating an image would be really useful when trying to generate a lot of images for training an object detector
# the same object, ideally, should be detectable at various angles, the training set of which can be generated by rotating images

# rotation: performed by multiplying an image matrix (I) by a transformation matrix (M) to obtain a resulting (R) matrix
# i.e., R = I * M, 
# Where M = [
# [cos(t), -sin(t)],
# [sin(t), cos(t)]
#]

# There is a more generalized matrix that OpenCV uses to perform a transformation, which accounts for:
# 1. rotation (as before)
# 2. scaling (enlarging/shrinking)
# 3. axis of rotation (x, y coordination around which a rotation is performed)
# 4. translation (shifting the image around, as mentioned in module 4)
# for details, see: https://pyimagesearch.com/2021/01/20/opencv-rotate-image/?_ga=2.227769630.2013290942.1700757874-1842902230.1698424416

import argparse
import imutils
import cv2

ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", type=str, default="/Users/kuanhc96/Desktop/pyimagesearch/opencv-5-rotate/paul_and_i.jpg", help="path to input image")
args = vars(ap.parse_args())

image = cv2.imread(args["image"])
cv2.imshow("Original", image)

(h, w) = image.shape[:2]
(cX, cY) = (w // 2, h // 2) # get center of image

M = cv2.getRotationMatrix2D((cX, cY), 45, 1.0) # positive degrees: counterclockwise; negative degress: clockwise. Think about the rotational coordinate system
# The idea of affine transformation: y = Ax + b, where A is the affine (rotation) matrix, b is a constant shift, and x, y are the original and resulting coordinates, respecitvely
rotated = cv2.warpAffine(image, M, (w, h)) 
cv2.imshow("Rotated counterclockwise by 45 Degrees", rotated)

(qX, qY) = (w // 4, h // 4)
M = cv2.getRotationMatrix2D((qX, qY), -80, 1.0)
rotated = cv2.warpAffine(image, M, (w, h)) 
cv2.imshow("Rotated center of 1 quadrant clockwise by 80 Degrees", rotated)

rotated = imutils.rotate(image, -10)
cv2.imshow("Rotated clockwise by 10 Degrees", rotated)

rotated = imutils.rotate_bound(image, 10) # looks like rotate bound will shrink the image a bit
cv2.imshow("Rotated clockwise by 10 Degrees, bounded", rotated)

# looks like imutils.rotate and imutils.rotate_bound rotate the images in different directions.
# imutils.rotate:
# negative degrees: clockwise; positive degrees: counter clockwise
# imutils.rotate_bound:
# negative degrees: counter clockwise; positive degrees: clockwise

cv2.waitKey(0)